# -*- coding: utf-8 -*-
"""
Created on Sat Dec  8 23:23:49 2018

@author: Miklos Vecsei, Fusion Plasma Physics Department, Centre for Energy Research

Spatial calibration of the for W7-X alkali BES diagnostic module for flap
"""

import os.path
import h5py
import numpy as np
from scipy.ndimage import median_filter
from scipy.optimize import minimize
from functools import partial
from matplotlib import pyplot as plt
from matplotlib import gridspec
from collections import OrderedDict
import flap
import flap_w7x_abes


class ShotSpatCal(flap.DataObject):
    ''' Object used for reading and generating the spatial data of the alkali beam
    for a specific shot
    '''

    def __init__(self, shotID, options=None):
        self.shotID = shotID
        shotyear = self.shotID[:4]
        if int(shotyear) < 2022:
            self.calibration_id = "2018"
        else:
            self.calibration_id = "2021"

    def full_calib(self, options={}):
        ''' Performs a spatial calibration for a given shot
        INPUT:
            options - dictionary, passed to the CalcCalibration object
        OUTPUS: the hdf5 files storing the adpcam-to-cmos and cmos-to-machine spatial calibration data
        '''

        CalcCalibration(self.calibration_id, options=options)

    def read(self, options={}):
        ''' Reads the hdf5 spatcal file. Can read the older spatial calibration files generated by idl and the newer
        ones generated by this module.
        INPUT: options: 'Shot spatcal dir' - the location of the shotID_spat.cal file
        OUTPUT: Defines self.calibration - ID for the calibration source, e.g. "2018"
                        self.beam_start_im, self.beam_end_im - the start and end of the beam in CMOS coordinates
                        self.beam_start_beam, self.beam_end_beam - the start and end of the beam in beam coordinates
                        self.beam_start_xyz, self.beam_end_xyz - the start and end of the beam in machine xyz coordinate
                        self.fibre_coords_beam - the location of the fibres in beam coordinates
                        self.fibres - the name of the fibres
                        self.beam_plane_vector - a unit vector in the beam plane, perpendicular to the beam
                        self.data - dictionary of 'Channel name', 'Device x', 'Device y', 'Device z', 'Device R',
                                    'Device Z' and 'Beam axis' coordinates
        '''
        import pickle
        options_default = {
            'Shot spatcal dir': os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                             'spatcal')}
        options = {**options_default, **options}

        spatcal_dir = options['Shot spatcal dir']
        fn = os.path.join(spatcal_dir, self.shotID + '_spat.cal')
        try:
            h5File = flap.load(fn)
            channel_names = np.array(h5File['Channels'])
            fibres = h5File["Fibres"]
            self.calibration = h5File["Calibration ID"]
            self.beam_start_im = h5File["Beam_start_im"]
            self.beam_end_im = h5File["Beam_end_im"]
            fibre_coords_im = h5File["Fibre_coords_im"]
            self.beam_start_beam = h5File["Beam_start_beam"]
            self.beam_end_beam = h5File["Beam_end_beam"]
            fibre_coords_beam = h5File["Fibre_coords_beam"]
            self.beam_start_xyz = h5File["Beam_start_xyz"]
            self.beam_end_xyz = h5File["Beam_end_xyz"]
            fibre_coords_xyz = h5File["Fibre_coords_xyz"]
            self.beam_plane_vector = h5File["Beam_plane_vector"]
        except pickle.UnpicklingError:
            with h5py.File(fn, "r", libver='earliest') as h5File:
                channel_names = h5File['/Channels'][:]
                channel_names = np.array(
                    [ch.decode('utf-8') for ch in channel_names])
                fibres = h5File["/Fibres"][:]
                self.calibration = h5File["/Calibration"][:][0].decode("utf-8")
                self.beam_start_im = h5File["/Beam_start_im"][:]
                self.beam_end_im = h5File["/Beam_end_im"][:]
                fibre_coords_im = h5File["/Fibre_coords_im"][:]
                self.beam_start_beam = h5File["/Beam_start_beam"][:]
                self.beam_end_beam = h5File["/Beam_end_beam"][:]
                fibre_coords_beam = h5File["/Fibre_coords_beam"][:]
                self.beam_start_xyz = h5File["/Beam_start_xyz"][:]
                self.beam_end_xyz = h5File["/Beam_end_xyz"][:]
                fibre_coords_xyz = h5File["/Fibre_coords_xyz"][:]
                self.beam_plane_vector = h5File["/Beam_plane_vector"][:]

        if 'Channels' in options.keys():
            channels = [bytes(channel, "utf-8")
                        for channel in options["Channels"]]
        else:
            channels = [bytes('ABES-'+str(index), 'utf-8')
                        for index in range(1, 41)]

        relative_loc = np.zeros(len(channel_names))
        index = 0
        for ch in channels:
            if type(ch) == bytes:
                ch = ch.decode('utf-8')
            relative_loc[np.where(channel_names == ch)[0][0]] = index+1
            index = index+1
        relative_loc = [x-1 if x >
                        0 else len(channel_names) for x in relative_loc]
        relative_loc = np.argsort(relative_loc)

        channel_names = channel_names[relative_loc]
        self.fibres = fibres[relative_loc]
        self.fibre_coords_im = fibre_coords_im[:, relative_loc]
        fibre_coords_beam = fibre_coords_beam[:, relative_loc]
        fibre_coords_xyz = fibre_coords_xyz[:, relative_loc]

        self.data = {
            "Channel name": np.array(channel_names),
            "Device x": fibre_coords_xyz[0, :],
            "Device y": fibre_coords_xyz[1, :],
            "Device z": fibre_coords_xyz[2, :],
            "Device R": np.sqrt(fibre_coords_xyz[0, :]**2+fibre_coords_xyz[1, :]**2),
            "Device Z": fibre_coords_xyz[2, :],
            "Beam axis": fibre_coords_beam[0, :]
        }
        return

    def create_coordinate_object(self, dimension_list, coord_name, channel_names=None):
        ''' Helper function for creating a flap.Coordinate object
        '''
        if not (channel_names is None):
            data = np.zeros(len(channel_names))
            index = 0
            for channel in channel_names:
                data[index] = (self.data[coord_name])[np.where(
                    self.data["Channel name"] == str(channel))[0][0]]
                index = index+1
        else:
            data = self.data[coord_name]

        coord_object = flap.Coordinate(name=coord_name, unit='m', values=data, shape=np.shape(data),
                                       mode=flap.CoordinateMode(equidistant=False), dimension_list=dimension_list)

        return coord_object

    def generate_shotdata(self, options={}):
        ''' Generates the spatial calibration data from the apdcam_to_cmos.hdf5 and cmost_to_machine.hdf5 files and the
        shot xml information
        INPUT:
            options: Calibration ID - per default the first three characters of the shot which is usually the year of
                                      the shot
                     Spatial calib source dir - the location of the Calibration ID folder, per default the location of
                                             this file + /spatcal
                     Shot spatcal dir - where to save the spatial calibration file, per default the location of
                                        this file + /spatcal
                     Overwrite - whether to overwrite an already existing spatial calibration data
                     Datapath - where to find the xml files of the current shot
                     Plot - whether to plot the image coordinates of the fibres and the beam
        OUTPUt: The calibration data is saved with flap.save() to 'Shot spatcal dir'
        '''
        options_default = {
            'Calibration ID': self.calibration_id,
            'Spatial calib source dir': os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                                     'spatcal'),
            'Shot spatcal dir': os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                             'spatcal'),
            'Overwrite': False,
            'Datapath': flap.config.get("Module W7X_ABES", "Datapath"),
            'Plot': False}
        options = {**options_default, **options}
        
        # self.generate_apdcam_shotdata(options=options)
        self.generate_cxrs_shotdata(options=options)
        

    def generate_apdcam_shotdata(self,options={}):

        shotspatcal_filename = os.path.join(
            options['Shot spatcal dir'], self.shotID + '_spat.cal')
        if os.path.isfile(shotspatcal_filename) is True and options['Overwrite'] is False:
            raise FileExistsError('Spatial calibration file ' + shotspatcal_filename + ' already exists\n' +
                                  "\t\t\t\tSet options['Overwrite'] = True to overwrite the file.")

        # opening the relevant calibration files
        filename = os.path.join(options['Spatial calib source dir'], options['Calibration ID'],
                                'Geometry', 'apdcam_to_cmos.hdf5')
        apdcam_to_cmos = flap.load(filename)

        cmos_apdcam_trans_mat = apdcam_to_cmos['Transformation matrix']
        chan_cent = apdcam_to_cmos['APDCAM channel centers']
        filename = os.path.join(options['Spatial calib source dir'], options['Calibration ID'],
                                'Geometry', 'cmos_to_real.hdf5')
        projections = flap.load(filename)
        cmos_to_real = projections['CMOS to machine projection']
        real_to_cmos = projections['Machine to CMOS projection']
        opt_axis_norm = projections['Optical axis vector']
        obs_point = projections['Observation point']
        image_x_vector = projections['Direction of image x axis']
        image_y_vector = projections['Direction of image y axis']
        midplane_crosspoint = projections['Midplane crosspoint']

        # Get micrometer settings
        datapath_base = options['Datapath']
        datapath = os.path.join(datapath_base, self.shotID)
        xmlfile = os.path.join(datapath, self.shotID + '_config.xml')
        xml = flap.FlapXml()
        xml.read_file(xmlfile)
        try:
            if (xml.head.tag != 'ShotSettings'):
                raise ValueError(
                    "No ShotSettings entry found in XML file " + xmlfile + ".")
            if (xml.head.attrib['Experiment'] != "W7-X A-BES"):
                raise ValueError(xmlfile + " is not a W7-X ABES config file.")
        except Exception:
            raise ValueError("File format error in " + xmlfile)
        config = flap_w7x_abes.abes_get_config(xml)

        # Reading the beam coordinates
        filename = os.path.join(
            options['Spatial calib source dir'], options['Calibration ID'], 'Geometry', 'beam.dat')
        with open(filename) as beam_data:
            lines = beam_data.readlines()
            beam_start = np.asarray(
                [float(data) for data in lines[2].rstrip().split(' ') if data != ''])
            beam_end = np.asarray(
                [float(data) for data in lines[3].rstrip().split(' ') if data != ''])
            beam_norm = beam_end-beam_start
            beam_norm = beam_norm/np.linalg.norm(beam_norm)
            beam_plane_vector = np.cross(beam_norm, np.asarray([0, 0, 1]))

        # Calculating the position of the channels on the CMOS image
        shot_channel_cent = OrderedDict()
        fibres = []
        for channel in config['signal_list']:
            new_channel_name = channel
            if channel[:4] == 'ABES':
                new_channel_name = channel[5:]
            if new_channel_name in chan_cent.keys():
                lab_config = chan_cent[new_channel_name][1]
                fibres += [chan_cent[new_channel_name][0]]
                if type(lab_config[0]) is list:
                    lab_config = lab_config[0]
                h_del = config['H-Micrometer'] - lab_config[0]
                v_del = config['V-Micrometer'] - lab_config[1]
                chan_cent_move = np.dot(
                    cmos_apdcam_trans_mat, np.array([h_del, v_del]))
                curr_chan_cent = np.asarray([lab_config[2]+chan_cent_move[0],
                                             lab_config[3]+chan_cent_move[1]])
                shot_channel_cent.update({channel: curr_chan_cent})

        # Calculating the position of the channels in the machine, assuming that they are in the z=0 plane
        for key in shot_channel_cent.keys():
            point_XY = get_points_projection(np.asarray([shot_channel_cent[key]]),
                                             cmos_to_real)
            point_machine_coord = image_x_vector*point_XY[0][0] +\
                image_y_vector*point_XY[0][1] +\
                midplane_crosspoint

            # Getting the cross point of observation point - point_machine_coord line on the z=0 plane
            connecting_vector = obs_point - point_machine_coord
            length_along_vector = -obs_point[2]/connecting_vector[2]
            shot_channel_cent[key] = {'Fibre coords im': shot_channel_cent[key],
                                      'Device xyz': obs_point + connecting_vector * length_along_vector}
            # Adding the beam axis coord
            coord_from_beam_start = shot_channel_cent[key]['Device xyz']-beam_start
            shot_channel_cent[key].update({'Beam coord': np.asarray([np.dot(coord_from_beam_start, beam_norm),
                                                                     np.linalg.norm(coord_from_beam_start - beam_norm *
                                                                                    np.dot(coord_from_beam_start, beam_norm))*
                                                                     np.sign((coord_from_beam_start - beam_norm *
                                                                                    np.dot(coord_from_beam_start, beam_norm))[1])])})

        # Everything of interest is done. The next part is just saving everything the same manner as it was
        # for the idl code
        calibconf = MachineCalibConfig()
        beam_points = calibconf.get_image_XY_coord([beam_start, beam_end], obs_point=obs_point,
                                                   opt_axis_norm=opt_axis_norm,
                                                   image_x_vector=image_x_vector,
                                                   image_y_vector=image_y_vector)
        beam_im = get_points_projection(np.asarray(beam_points), real_to_cmos)

        object_dict = {'Version': 'flap_1.0',
                       'Calibration ID': str(options['Calibration ID']),
                       'Channels': np.array(list(shot_channel_cent.keys())),
                       'Fibres': np.asarray(fibres),
                       'Beam_start_im': beam_im[0, :],
                       'Beam_end_im': beam_im[1, :],
                       'Beam_start_xyz': beam_start,
                       'Beam_end_xyz': beam_end,
                       'Beam_start_beam': np.asarray([0, 0]),
                       'Beam_end_beam': beam_end-beam_start,
                       'Beam_plane_vector': beam_plane_vector}

        fibre_coords_xyz = []
        fibre_coords_beam = []
        fibre_coords_im = []
        for chan in shot_channel_cent.keys():
            fibre_coords_xyz = fibre_coords_xyz + \
                [list(shot_channel_cent[chan]['Device xyz'])]
            fibre_coords_im = fibre_coords_im + \
                [list(shot_channel_cent[chan]['Fibre coords im'])]
            fibre_coords_beam = fibre_coords_beam + \
                [shot_channel_cent[chan]['Beam coord']]
        fibre_coords_im = np.transpose(np.asarray(fibre_coords_im))
        fibre_coords_xyz = np.transpose(np.asarray(fibre_coords_xyz))
        fibre_coords_beam = np.transpose(np.asarray(fibre_coords_beam))
        object_dict_update = {'Fibre_coords_beam': fibre_coords_beam,
                              'Fibre_coords_im': fibre_coords_im,
                              'Fibre_coords_xyz': fibre_coords_xyz}

        object_dict.update(object_dict_update)
        flap.save(object_dict, shotspatcal_filename)

        if options['Plot'] is True:
            plt.figure()
            # Plotting the image coordinates
            plt.subplot(1, 3, 1)
            plt.title("Location on CMOS")
            plt.scatter(fibre_coords_im[0],
                        fibre_coords_im[1], color='tab:red')
            plt.plot(np.asarray([beam_im[0, 0], beam_im[1, 0]]), [
                     beam_im[0, 1], beam_im[1, 1]], color='tab:blue')
            plt.scatter(beam_im[0, 0], beam_im[0, 1], color='tab:blue')
            # Plotting the channel radii
            plt.subplot(1, 3, 2)
            plt.title("Location along BEAM")
            points = np.sort(
                np.sqrt(fibre_coords_xyz[0]**2+fibre_coords_xyz[1]**2))
            points = fibre_coords_beam
            plt.scatter(points[0], points[1], label='new', color="tab:red")
            # Plotting the machine coordinates
            plt.subplot(1, 3, 3)
            plt.title("Location in real space")
            plt.scatter(fibre_coords_xyz[0],
                        fibre_coords_xyz[1], color='tab:red')
            plt.plot([beam_start[0], beam_end[0]], [
                        beam_start[1], beam_end[1]], color='tab:blue')
            plt.scatter(beam_start[0], beam_start[1], color='tab:blue')
            plt.show(block=False)
            plt.pause(0.01)
            
    def generate_cxrs_shotdata(self,options={}):

        shotspatcal_filename = os.path.join(
            options['Shot spatcal dir'], self.shotID + '_cxrs_spat.cal')
        if os.path.isfile(shotspatcal_filename) is True and options['Overwrite'] is False:
            raise FileExistsError('Spatial calibration file ' + shotspatcal_filename + ' already exists\n' +
                                  "\t\t\t\tSet options['Overwrite'] = True to overwrite the file.")

        # opening the relevant calibration files
        filename = os.path.join(options['Spatial calib source dir'], options['Calibration ID'],
                                'Geometry', 'cxrs_to_cmos.hdf5')
        cxrs_to_cmos = flap.load(filename)

        cmos_cxrs_trans_mat = cxrs_to_cmos['Transformation matrix']
        chan_cent = cxrs_to_cmos['CXRS channel centers']
        filename = os.path.join(options['Spatial calib source dir'], options['Calibration ID'],
                                'Geometry', 'cmos_to_real.hdf5')
        projections = flap.load(filename)
        cmos_to_real = projections['CMOS to machine projection']
        real_to_cmos = projections['Machine to CMOS projection']
        opt_axis_norm = projections['Optical axis vector']
        obs_point = projections['Observation point']
        image_x_vector = projections['Direction of image x axis']
        image_y_vector = projections['Direction of image y axis']
        midplane_crosspoint = projections['Midplane crosspoint']

        # # Get micrometer settings
        # datapath_base = options['Datapath']
        # datapath = os.path.join(datapath_base, self.shotID)
        # xmlfile = os.path.join(datapath, self.shotID + '_config.xml')
        # xml = flap.FlapXml()
        # xml.read_file(xmlfile)
        # try:
        #     if (xml.head.tag != 'ShotSettings'):
        #         raise ValueError(
        #             "No ShotSettings entry found in XML file " + xmlfile + ".")
        #     if (xml.head.attrib['Experiment'] != "W7-X A-BES"):
        #         raise ValueError(xmlfile + " is not a W7-X ABES config file.")
        # except Exception:
        #     raise ValueError("File format error in " + xmlfile)
        # config = flap_w7x_abes.abes_get_config(xml)

        # Reading the beam coordinates
        filename = os.path.join(
            options['Spatial calib source dir'], options['Calibration ID'], 'Geometry', 'beam.dat')
        with open(filename) as beam_data:
            lines = beam_data.readlines()
            beam_start = np.asarray(
                [float(data) for data in lines[2].rstrip().split(' ') if data != ''])
            beam_end = np.asarray(
                [float(data) for data in lines[3].rstrip().split(' ') if data != ''])
            beam_norm = beam_end-beam_start
            beam_norm = beam_norm/np.linalg.norm(beam_norm)
            beam_plane_vector = np.cross(beam_norm, np.asarray([0, 0, 1]))

        # Calculating the position of the channels on the CMOS image
        from .cxrs import read_fibre_config
        patch_dict = read_fibre_config(self.calibration_id)
        connected = [key for key in patch_dict.keys() if ('N.A' not in patch_dict[key].upper()
                                                          and 'N.A' not in patch_dict[key].upper())]
        
        microA = 1.20
        microB = 4.13
        shot_channel_cent = OrderedDict()
        fibres = []
        for key in connected:
            channel = patch_dict[key]
            new_channel_name = channel
            if key in chan_cent.keys():
                lab_config = chan_cent[key][1]
                fibres += [chan_cent[key][0]]
                if type(lab_config[0]) is list:
                    lab_config = lab_config[0]
                a_del = microA - lab_config[0]
                b_del = microB - lab_config[1]
                chan_cent_move = np.dot(
                    cmos_cxrs_trans_mat, np.array([a_del, b_del]))
                curr_chan_cent = np.asarray([lab_config[2]+chan_cent_move[0],
                                             lab_config[3]+chan_cent_move[1]])
                shot_channel_cent.update({channel: curr_chan_cent})

        # Calculating the position of the channels in the machine, assuming that they are in the z=0 plane
        for key in shot_channel_cent.keys():
            point_XY = get_points_projection(np.asarray([shot_channel_cent[key]]),
                                             cmos_to_real)
            point_machine_coord = image_x_vector*point_XY[0][0] +\
                image_y_vector*point_XY[0][1] +\
                midplane_crosspoint

            # Getting the cross point of observation point - point_machine_coord line on the z=0 plane
            connecting_vector = obs_point - point_machine_coord
            length_along_vector = -obs_point[2]/connecting_vector[2]
            shot_channel_cent[key] = {'Fibre coords im': shot_channel_cent[key],
                                      'Device xyz': obs_point + connecting_vector * length_along_vector}
            # Adding the beam axis coord
            coord_from_beam_start = shot_channel_cent[key]['Device xyz']-beam_start
            shot_channel_cent[key].update({'Beam coord': np.asarray([np.dot(coord_from_beam_start, beam_norm),
                                                                     np.linalg.norm(coord_from_beam_start - beam_norm *
                                                                                    np.dot(coord_from_beam_start, beam_norm))*
                                                                     np.sign((coord_from_beam_start - beam_norm *
                                                                                    np.dot(coord_from_beam_start, beam_norm))[1])])})

        # Everything of interest is done. The next part is just saving everything the same manner as it was
        # for the idl code
        calibconf = MachineCalibConfig()
        beam_points = calibconf.get_image_XY_coord([beam_start, beam_end], obs_point=obs_point,
                                                   opt_axis_norm=opt_axis_norm,
                                                   image_x_vector=image_x_vector,
                                                   image_y_vector=image_y_vector)
        beam_im = get_points_projection(np.asarray(beam_points), real_to_cmos)

        object_dict = {'Version': 'flap_1.0',
                       'Calibration ID': str(options['Calibration ID']),
                       'Channels': np.array(list(shot_channel_cent.keys())),
                       'Fibres': np.asarray(fibres),
                       'Beam_start_im': beam_im[0, :],
                       'Beam_end_im': beam_im[1, :],
                       'Beam_start_xyz': beam_start,
                       'Beam_end_xyz': beam_end,
                       'Beam_start_beam': np.asarray([0, 0]),
                       'Beam_end_beam': beam_end-beam_start,
                       'Beam_plane_vector': beam_plane_vector}

        fibre_coords_xyz = []
        fibre_coords_beam = []
        fibre_coords_im = []
        for chan in shot_channel_cent.keys():
            fibre_coords_xyz = fibre_coords_xyz + \
                [list(shot_channel_cent[chan]['Device xyz'])]
            fibre_coords_im = fibre_coords_im + \
                [list(shot_channel_cent[chan]['Fibre coords im'])]
            fibre_coords_beam = fibre_coords_beam + \
                [shot_channel_cent[chan]['Beam coord']]
        fibre_coords_im = np.transpose(np.asarray(fibre_coords_im))
        fibre_coords_xyz = np.transpose(np.asarray(fibre_coords_xyz))
        fibre_coords_beam = np.transpose(np.asarray(fibre_coords_beam))
        object_dict_update = {'Fibre_coords_beam': fibre_coords_beam,
                              'Fibre_coords_im': fibre_coords_im,
                              'Fibre_coords_xyz': fibre_coords_xyz}

        object_dict.update(object_dict_update)
        flap.save(object_dict, shotspatcal_filename)

        if options['Plot'] is True:
            plt.figure()
            # Plotting the image coordinates
            plt.subplot(1, 3, 1)
            plt.title("Location on CMOS")
            file = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                'spatcal', self.calibration_id, '13_52a557d22_1636047256870.png')
            data = plt.imread(file)
            plt.imshow(data, cmap='gray')
            fibres_plot = []
            for key in patch_dict:
                channel = patch_dict[key]
                new_channel_name = channel
                if key in chan_cent.keys():
                    lab_config = chan_cent[key][1]
                    fibres += [chan_cent[key][0]]
                    if type(lab_config[0]) is list:
                        lab_config = lab_config[0]
                    a_del = microA - lab_config[0]
                    b_del = microB - lab_config[1]
                    chan_cent_move = np.dot(
                        cmos_cxrs_trans_mat, np.array([a_del, b_del]))
                    curr_chan_cent = np.asarray([lab_config[2]+chan_cent_move[0],
                                                 lab_config[3]+chan_cent_move[1]])
                    plt.scatter(curr_chan_cent[0], curr_chan_cent[1], color='gray', alpha=0.5)
            plt.scatter(fibre_coords_im[0],
                    fibre_coords_im[1], color='tab:red')
            index = 0
            for channel in object_dict['Channels']:
                plt.text(fibre_coords_im[0][index]+5,
                      fibre_coords_im[1][index], str(channel).split('.')[1], color='tab:red')
                index += 1
            plt.plot(np.asarray([beam_im[0, 0], beam_im[1, 0]]), [
                     beam_im[0, 1], beam_im[1, 1]], color='tab:blue')
            plt.scatter(beam_im[0, 0], beam_im[0, 1], color='tab:blue')
            plt.axis('equal')
            plt.xlim([np.min(fibre_coords_im[0])-50, np.max(fibre_coords_im[0])+50])
            plt.ylim([beam_im[0, 1]-50, np.max(fibre_coords_im[1])+50])
            # Plotting the channel radii
            plt.subplot(1, 3, 2)
            plt.title("Location along BEAM")
            points = np.sort(
                np.sqrt(fibre_coords_xyz[0]**2+fibre_coords_xyz[1]**2))
            points = fibre_coords_beam
            plt.scatter(points[0], points[1], label='new', color="tab:red")
            # Plotting the machine coordinates
            plt.subplot(1, 3, 3)
            plt.title("Location in real space")
            plt.scatter(fibre_coords_xyz[0],
                        fibre_coords_xyz[1], color='tab:red')
            index = 0
            for channel in object_dict['Channels']:
                plt.text(fibre_coords_xyz[0][index]+0.003,
                      fibre_coords_xyz[1][index], f"{str(channel).split('.')[1]}: {fibre_coords_xyz[0][index], fibre_coords_xyz[1][index]}", color='tab:red')
                index += 1
            plt.plot([beam_start[0], beam_end[0]], [
                        beam_start[1], beam_end[1]], color='tab:blue')
            plt.scatter(beam_start[0], beam_start[1], color='tab:blue')
            plt.show(block=False)
            plt.pause(0.01)


class CalcCalibration:
    # Object used for processing the apdcam to cmos and cmos to machine spatial calibration

    def __init__(self, calibration_id, options={}):
        '''Performs the requested spatial calibration calculations
        INPUT:
            calibration_id: a string of the data calibration
            options: Spatial calib source dir: The location of the calibration data - per default the location of this file +
                                         /spatcal
                     Get APDCAM to CMOS: Boolean, whether to process the apdcam to cmos calibration files and create the
                                         apdcam_to_cmos.hdf5 file
                     Get CMOS to machine: Boolean, whether to process the cmos to machine calibration and create the
                                         cmos_to_machine.hdf5 file
                     Type: Value either 'Points' or 'Fiducial' - Only relevant for  CMOS to machine calibration. Defines
                           whether the calibration is based on fixed points on the image with known machine coordinates
                           or on fiducial curves with known parameters in the machine
        OUTPUT:
            The calibration data saved in the cmos_to_machine.hdf5 and apdcam_to_machine.hdf5 files
        '''

        options_default = {
            'Spatial calib source dir': os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                                     'spatcal'),
            'Get APDCAM to CMOS': True,
            'Get CMOS to machine': True,
            'Get CXRS to CMOS': True,
            'Type': 'Points'}
        options = {**options_default, **options}

        self.calibration_id = calibration_id

        if options['Get APDCAM to CMOS'] is True:
            self.process_apdcam_to_cmos_calib(options)
            # self.apdcam_chan_cent is a directory with keys of the channel names and contains h0, v0, cx0, cy0
            data_to_save = {'Transformation matrix': self.cmos_apdcam_trans_mat,
                            'APDCAM channel centers': self.apdcam_chan_cent}
            filename = os.path.join(options['Spatial calib source dir'], self.calibration_id,
                                    'Geometry', 'apdcam_to_cmos.hdf5')
            print('saving '+filename)
            flap.save(data_to_save, filename)
            print("done")

        if options['Get CXRS to CMOS'] is True:
            self.process_cxrs_to_cmos_calib(options)
            # self.apdcam_chan_cent is a directory with keys of the channel names and contains h0, v0, cx0, cy0
            data_to_save = {'Transformation matrix': self.cmos_cxrs_trans_mat,
                            'CXRS channel centers': self.cxrs_chan_cent}
            filename = os.path.join(options['Spatial calib source dir'], self.calibration_id,
                                    'Geometry', 'cxrs_to_cmos.hdf5')
            print('saving '+filename)
            flap.save(data_to_save, filename)
            print("done")

        if options['Get CMOS to machine'] is True:
            self.process_cmos_to_machine_calib(options=options)
            data_to_save = {'CMOS to machine projection': self.cmos_to_real,
                            'Machine to CMOS projection': self.real_to_cmos,
                            'Optical axis vector': self.calibconf.opt_axis_norm,
                            'Observation point': self.calibconf.obs_point,
                            'Direction of image x axis': self.calibconf.image_x_vector,
                            'Direction of image y axis': self.calibconf.image_y_vector,
                            'Midplane crosspoint': self.calibconf.midplane_crosspoint}

            filename = os.path.join(
                options['Spatial calib source dir'], self.calibration_id, 'Geometry', 'cmos_to_real.hdf5')
            print('saving '+filename)
            flap.save(data_to_save, filename)
            print("done")

    def read_apdcam_apdcam_fibre_calib_list(self, options):
        ''' Reads the apdcam_fibre_calib_images.dat file information
        '''
        options_default = {}
        options = {**options_default, **options}

        filename = os.path.join(
            options['Spatial calib source dir'], self.calibration_id, 'apdcam_fibre_calib_images.dat')
        self.apdcam_fibre_calib_list = []

        with open(filename) as fibre_list:
            lines = fibre_list.readlines()
            for line_index in range(1, len(lines)):
                line_data = [data for data in lines[line_index].split(
                    "\t") if data != ""]
                self.apdcam_fibre_calib_list += [[line_data[0], float(line_data[1]), float(
                    line_data[2]), line_data[3], line_data[4][:-1]]]
        return self.apdcam_fibre_calib_list

    def process_apdcam_to_cmos_calib(self, options):
        ''' Processing the apdcam to cmos calibration data
        INPUT: options - Spatial calib source dir - the location of the calibration files
                         Noise limit - a limit value, below which the noise is removed from the images
                         Calculate micrometer angle: boolean, prints out the angle between the horizontal and vertical
                                                      micrometer
                         Plot - whether to plot the cmos image corresponding to the measurements
                         Flip horizontally - Looking at the dead pixels, it was found that the 2017-2018 laboratory
                         calibration CMOS images were flipped horizontally relative to the stellarator images,
                         this can be corrected by setting this option to True
        OUTPUT: the follwing variables are created
            self.cmos_apdcam_trans_mat - 2*2 linear transformation matrix for calculating the position of the
                                             channels based on the micrometer settings
            self.apdcam_chan_cent - dictionary with keys of the channel names. Stores the location of the apdcam centers on
                             the CMOS image and their fibre names
        '''
        options_default = {
            'Spatial calib source dir': os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                                     'spatcal'),
            'Noise limit': 100,
            'Calculate micrometer angle': False,
            'Plot': True,
            'Flip horizontally': False}
        options = {**options_default, **options}

        if hasattr(self, 'apdcam_fibre_calib_list') is False:
            self.read_apdcam_apdcam_fibre_calib_list(options)

        transform_points = False
        first_image = True
        for image_params in self.apdcam_fibre_calib_list:
            if image_params[3][-3:] == 'bmp':
                split_filename = image_params[3].split('.')
                split_filename[-1] = 'png'
                image_params[3] = '.'.join(split_filename)
            if first_image == True:
                if int(image_params[4]) != int(self.calibration_id):
                    transform_points = True
                    a, B = self.calc_apdcam_cmos_transform(
                        options['Flip horizontally'])
                if options['Plot'] is False:
                    first_image = False

            image = plt.imread(os.path.join(
                options['Spatial calib source dir'], image_params[4], image_params[3]))
            image = np.asarray(image)
            if options['Flip horizontally'] is True:
                image = np.fliplr(image)
            # removing the background and the dead pixels
            try:
                image_filtered = image/np.var(image)
                image_filtered = image_filtered-np.median(image_filtered)
                image_filtered[image_filtered < options['Noise limit']] = 0
                image_filtered = median_filter(image_filtered, size=3)

                # adding the location of the center of the channel to the self.apdcam_fibre_calib_list variable
                x_weight = np.sum(image_filtered, axis=0)
                y_weight = np.sum(image_filtered, axis=1)

                x_center = np.average(
                    np.arange(len(x_weight)), weights=x_weight)
                y_center = np.average(
                    np.arange(len(y_weight)), weights=y_weight)

            except ZeroDivisionError:  # this my happen for different calibration images, these need to be filtered differently
                image_filtered = image/np.var(image)
                image_filtered[np.where(
                    image_filtered < np.max(image_filtered)*0.5)] = 0

                # adding the location of the center of the channel to the self.apdcam_fibre_calib_list variable
                x_weight = np.sum(image_filtered, axis=0)
                y_weight = np.sum(image_filtered, axis=1)

                x_center = np.average(
                    np.arange(len(x_weight)), weights=x_weight)
                y_center = np.average(
                    np.arange(len(y_weight)), weights=y_weight)

            if options['Plot'] is True:
                plt.contourf(image_filtered)
                plt.scatter(x_center,
                            y_center, color='red')
                plt.show(block=False)
                plt.pause(0.01)
                if first_image == True:
                    imsum = image/np.max(image)
                    first_image = False
                else:
                    imsum = imsum + image/np.max(image)

            if transform_points == True:
                new_vect = a + np.dot(B, np.array([x_center, y_center]))
                [x_center, y_center] = new_vect

            image_params += [x_center, y_center]

        # Get the transformation matrix with the v and h micrometer
        # Finding the channels with multiple measurements and storing the corresponding data
        channel_meas = np.asarray(self.apdcam_fibre_calib_list)[:, 0]
        multi_chan_meas_id, chan_count = np.unique(
            channel_meas, return_counts=True)
        multi_chan_meas_id = multi_chan_meas_id[chan_count > 1]

        # Collecting the data for the channels with multiple measurements
        chan_cent = {}
        for chan in multi_chan_meas_id:
            chan_cent[chan] = list()
        for image_params in self.apdcam_fibre_calib_list:
            if image_params[0] in multi_chan_meas_id:
                chan_cent[image_params[0]] += [[image_params[1],
                                                image_params[2], image_params[5], image_params[6]]]
            else:
                chan_cent[image_params[0]] = [
                    [image_params[1], image_params[2], image_params[5], image_params[6]]]

        if options['Plot'] is True:
            plt.contourf(imsum)
            for image_params in self.apdcam_fibre_calib_list:
                plt.scatter(chan_cent[image_params[0]][0][2], chan_cent[image_params[0]][0][3],
                            color='red', marker='x')
            plt.show(block=False)
            plt.pause(0.01)

        # Creating an equation system for obtaining the elements of the transformation matrix
        for chan in multi_chan_meas_id:
            index = 0
            h0, v0, cx0, cy0 = chan_cent[chan][0]
            # The notation is the following A*[dh, dv] = [dcx, dcy] the goal is to find A
            for meas_id in range(1, len(chan_cent[chan])):
                curr_eq = [[chan_cent[chan][meas_id][0]-h0, chan_cent[chan][meas_id][1]-v0, 0, 0],
                           [0, 0, chan_cent[chan][meas_id][0]-h0, chan_cent[chan][meas_id][1]-v0]]
                curr_cent_move = [chan_cent[chan][meas_id]
                                  [2]-cx0, chan_cent[chan][meas_id][3]-cy0]
                if meas_id == 1 and index == 0:
                    eqsys = np.array(curr_eq)
                    cent_move = np.array(curr_cent_move)
                else:
                    eqsys = np.concatenate((eqsys, curr_eq), axis=0)
                    cent_move = np.concatenate((cent_move, curr_cent_move))
        trans_mat_sol = np.linalg.solve(np.dot(np.transpose(eqsys), eqsys),
                                        np.dot(np.transpose(eqsys), cent_move))
        trans_mat = np.array([trans_mat_sol[:2], trans_mat_sol[2:]])
        self.cmos_apdcam_trans_mat = trans_mat

        if options['Calculate micrometer angle'] is True:
            # Ideally the rows of self,trans_mat should be orthogonal. The angle can be calculated as
            cosa = (trans_mat[0, 0] * self.trans_mat[1, 0] + trans_mat[0, 1] * trans_mat[1, 1]) / \
                   (np.sqrt(trans_mat[0, 0]**2 + self.trans_mat[0, 1]**2)
                    * np.sqrt(trans_mat[1, 0]**2 + trans_mat[1, 1]**2))
            angle = np.arccos(cosa)*180 / np.pi  # should be around 90
            print("The angle between the horizontal and vertical micrometer: " +
                  str(angle)+" degrees")

        # Saving the center of the coordinates - it the APDCAM side is what we need, so the fibre-head configuraiton is
        # needed
        with open(os.path.join(options['Spatial calib source dir'], self.calibration_id, 'head_fibre_config.dat'), 'r')\
                as head_config:
            line = head_config.readline()
            head_config_map = {}
            while line:
                line = [name for name in head_config.readline(
                ).rstrip().split(' ') if name != '']
                if len(line) == 1:
                    line = [name for name in line[0].split('\t') if name != '']
                if len(line) != 0:
                    head_config_map.update({line[1]: line[0]})
        self.apdcam_chan_cent = {}
        for chan in chan_cent.keys():
            if chan in multi_chan_meas_id:
                curr_chan_data = {head_config_map[chan]: [
                    chan, chan_cent[chan][0]]}
            else:
                curr_chan_data = {
                    head_config_map[chan]: [chan, chan_cent[chan]]}
            self.apdcam_chan_cent.update(curr_chan_data)
        return self.cmos_apdcam_trans_mat
    
    def read_cxrs_fibre_calib_list(self, options):
        ''' Reads the apdcam_fibre_calib_images.dat file information
        '''
        options_default = {}
        options = {**options_default, **options}

        filename = os.path.join(
            options['Spatial calib source dir'], self.calibration_id, 'cxrs_fibre_calib_images.dat')
        self.cxrs_fibre_calib_list = []

        with open(filename) as fibre_list:
            lines = fibre_list.readlines()
            for line_index in range(1, len(lines)):
                line_data = [data for data in lines[line_index].split(
                    "\t") if data != ""]
                self.cxrs_fibre_calib_list += [[line_data[0], float(line_data[1]), float(
                    line_data[2]), line_data[3], line_data[4][:-1]]]
        return self.cxrs_fibre_calib_list
    
    def summall_cxrs_fibers(self, options={}):
        #this one only works properly if the micrometer settings have not been changed for the relevan imaages
        imagenum = 0
        for line in self.cxrs_fibre_calib_list:
            if line[0].upper() == 'ALL':
                currimage = plt.imread(os.path.join(
                        options['Spatial calib source dir'], self.calibration_id, line[3]))
                currimage = np.asarray(currimage)
                if imagenum == 0:
                    image = currimage
                    starting_micrometer_settings = [line[1], line[2]]
                else:
                    image += currimage
                imagenum += 1
            elif line[0].upper() == 'REFALL':
                refall = plt.imread(os.path.join(
                    options['Spatial calib source dir'], self.calibration_id, line[3]))
                refall = np.asarray(refall).astype("float")
                #taking out the yellowish part
                refall = refall[:,:,:3]
                yellow = np.zeros(refall.shape)
                condition = np.where((refall[:,:,0]/refall[:,:,1]>0.5)*
                                (refall[:,:,0]/refall[:,:,2]>0.9)*
                                (refall[:,:,0]>0.75))
                yellow[condition] = refall[condition]
                yellow = np.sum(yellow, axis=2)
                yellow = median_filter(yellow, size=3)
                yellow[np.where(yellow>0.5*np.mean(yellow))] = 1
        
        if self.calibration_id == "2021":
            image[580:680, 500:580] = np.median(image)
            image[:, :550] = np.median(image)
            image[:, 715:] = np.median(image)
        try:
            image_filtered = image/np.var(image)
            image_filtered = image_filtered-np.median(image_filtered)
            image_filtered[image_filtered < options['Noise limit']/1000*imagenum] = 0
            image_filtered = median_filter(image_filtered, size=3)
        except ZeroDivisionError:  # this my happen for different calibration images, these need to be filtered differently
            image_filtered = image/np.var(image)
            image_filtered[np.where(
                image_filtered < np.max(image_filtered)*0.5)] = 0

        return image_filtered, yellow, starting_micrometer_settings
    
    def process_cxrs_to_cmos_calib(self, options):
        ''' Processing the AEB21 cxrs to cmos calibration data
        INPUT: options - Spatial calib source dir - the location of the calibration files
                         Noise limit - a limit value, below which the noise is removed from the images
                         Calculate micrometer angle: boolean, prints out the angle between the horizontal and vertical
                                                      micrometer
                         Plot - whether to plot the cmos image corresponding to the measurements
                         Flip horizontally - Looking at the dead pixels, it was found that the 2017-2018 laboratory
                         calibration CMOS images were flipped horizontally relative to the stellarator images,
                         this can be corrected by setting this option to True
        OUTPUT: the follwing variables are created
            self.cmos_cxrs_trans_mat - 2*2 linear transformation matrix for calculating the position of the
                                             channels based on the micrometer settings
            self.cxrs_chan_cent - dictionary with keys of the channel names. Stores the location of the cxrs centers on
                             the CMOS image and their fibre names
        '''
        options_default = {
            'Spatial calib source dir': os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                                     'spatcal'),
            'Noise limit': 100,
            'Calculate micrometer angle': False,
            'Plot': False}
        options = {**options_default, **options}

        
        if hasattr(self, 'apdcam_fibre_calib_list') is False:
            self.read_cxrs_fibre_calib_list(options)
        summed_image, refimage, micrometer_settings = self.summall_cxrs_fibers(options=options)
        cxrs_to_cmos = self.calc_cxrs_cmos_transform(summed_image, refimage)



        first_image = True
        for image_params in self.cxrs_fibre_calib_list:
            if image_params[3][-3:] == 'bmp':
                split_filename = image_params[3].split('.')
                split_filename[-1] = 'png'
                image_params[3] = '.'.join(split_filename)
            
            if "lower_fibre_" in image_params[3]:
                
                image = plt.imread(os.path.join(
                    options['Spatial calib source dir'], image_params[4], image_params[3]))
                image = np.asarray(image)
                
                # removing the background and the dead pixels
                try:
                    # for colored images finding the 'yellow color'
                    image_filtered = image[:,:,:3]
                    yellow = np.zeros(image_filtered.shape)
                    condition = np.where((image_filtered[:,:,0]/image_filtered[:,:,1]>0.5)*
                                    (image_filtered[:,:,0]/image_filtered[:,:,2]>0.9)*
                                    (image_filtered[:,:,0]>0.75))
                    yellow[condition] = image_filtered[condition]
                    image_filtered = np.sum(yellow, axis=2)
                    image_filtered = median_filter(image_filtered, size=3)
                    image_filtered[np.where(image_filtered<0.75*np.median(image_filtered))] = 0
    
                    x_weight = np.sum(image_filtered, axis=0)
                    y_weight = np.sum(image_filtered, axis=1)
    
                    x_center = np.average(
                        np.arange(len(x_weight)), weights=x_weight)
                    y_center = np.average(
                        np.arange(len(y_weight)), weights=y_weight)
    
                except ZeroDivisionError:  # this my happen for different calibration images, these need to be filtered differently
                    image_filtered = image/np.var(image)
                    image_filtered[np.where(
                        image_filtered < np.max(image_filtered)*0.5)] = 0
    
                    # adding the location of the center of the channel to the self.apdcam_fibre_calib_list variable
                    x_weight = np.sum(image_filtered, axis=0)
                    y_weight = np.sum(image_filtered, axis=1)
    
                    x_center = np.average(
                        np.arange(len(x_weight)), weights=x_weight)
                    y_center = np.average(
                        np.arange(len(y_weight)), weights=y_weight)
    
                [cmos_x, cmos_y] = get_points_projection(np.asarray([[x_center, y_center]]), cxrs_to_cmos)[0]
                image_params += [cmos_x, cmos_y]
                image_params[1:3] = micrometer_settings
                if options['Plot'] is True:
                    plt.subplot(1,2,1)
                    plt.imshow(refimage)
                    plt.contourf(image_filtered, alpha=0.5)
                    plt.scatter(x_center,
                                y_center, color='red')
                    plt.subplot(1,2,2)
                    plt.imshow(summed_image)
                    plt.scatter(cmos_x, cmos_y, color='red')
                    plt.show()
                    plt.show(block=False)
                    plt.pause(0.05)
                    plt.clf()
            elif "ALL" not in image_params[0]:
                image = plt.imread(os.path.join(
                    options['Spatial calib source dir'], image_params[4], image_params[3]))
                image = np.asarray(image)
                
                # removing the background and the dead pixels
                try:
                    image_filtered = image/np.var(image)
                    image_filtered = image_filtered-np.median(image_filtered)
                    image_filtered[image_filtered < options['Noise limit']*10] = 0
                    image_filtered = median_filter(image_filtered, size=3)
                    image_filtered[np.where(image_filtered<0.75*np.median(image_filtered))] = 0
    
                    x_weight = np.sum(image_filtered, axis=0)
                    y_weight = np.sum(image_filtered, axis=1)
    
                    x_center = np.average(
                        np.arange(len(x_weight)), weights=x_weight)
                    y_center = np.average(
                        np.arange(len(y_weight)), weights=y_weight)

                except ZeroDivisionError:  # this my happen for different calibration images, these need to be filtered differently
                    image_filtered = image/np.var(image)
                    image_filtered[np.where(
                        image_filtered < np.max(image_filtered)*0.5)] = 0
    
                    # adding the location of the center of the channel to the self.apdcam_fibre_calib_list variable
                    x_weight = np.sum(image_filtered, axis=0)
                    y_weight = np.sum(image_filtered, axis=1)
    
                    x_center = np.average(
                        np.arange(len(x_weight)), weights=x_weight)
                    y_center = np.average(
                        np.arange(len(y_weight)), weights=y_weight)

                image_params += [x_center, y_center]

                if options['Plot'] is True:
                    plt.imshow(image_filtered)
                    plt.scatter(x_center,
                                y_center, color='red', marker='x')
                    plt.show()
                    plt.show(block=False)
                    plt.pause(0.05)
                    plt.clf()
                                

        # Get the transformation matrix with the A and B micrometer
        # Finding the channels with multiple measurements and storing the corresponding data
        channel_meas = np.array([line[0] for line in self.cxrs_fibre_calib_list])
        multi_chan_meas_id, chan_count = np.unique(
            channel_meas, return_counts=True)
        multi_chan_meas_id = multi_chan_meas_id[chan_count > 1]
        multi_chan_meas_id = [chan_id for chan_id in multi_chan_meas_id if 'ALL' not in chan_id]

        # Collecting the data for the channels with multiple measurements
        chan_cent = {}
        for chan in multi_chan_meas_id:
            chan_cent[chan] = list()
        for image_params in self.cxrs_fibre_calib_list:
            if image_params[0] in multi_chan_meas_id:
                chan_cent[image_params[0]] += [[image_params[1],
                                                image_params[2], image_params[5], image_params[6]]]                
            elif "ALL" not in image_params[0]:
                chan_cent[image_params[0]] = [
                    [image_params[1], image_params[2], image_params[5], image_params[6]]]

        # Creating an equation system for obtaining the elements of the transformation matrix
        for chan in multi_chan_meas_id:
            index = 0
            h0, v0, cx0, cy0 = chan_cent[chan][0]
            # The notation is the following A*[dh, dv] = [dcx, dcy] the goal is to find A
            for meas_id in range(1, len(chan_cent[chan])):
                curr_eq = [[chan_cent[chan][meas_id][0]-h0, chan_cent[chan][meas_id][1]-v0, 0, 0],
                           [0, 0, chan_cent[chan][meas_id][0]-h0, chan_cent[chan][meas_id][1]-v0]]
                curr_cent_move = [chan_cent[chan][meas_id]
                                  [2]-cx0, chan_cent[chan][meas_id][3]-cy0]
                if meas_id == 1 and index == 0:
                    eqsys = np.array(curr_eq)
                    cent_move = np.array(curr_cent_move)
                else:
                    eqsys = np.concatenate((eqsys, curr_eq), axis=0)
                    cent_move = np.concatenate((cent_move, curr_cent_move))
        trans_mat_sol = np.linalg.solve(np.dot(np.transpose(eqsys), eqsys),
                                        np.dot(np.transpose(eqsys), cent_move))
        trans_mat = np.array([trans_mat_sol[:2], trans_mat_sol[2:]])
        self.cmos_cxrs_trans_mat = trans_mat

        if options['Calculate micrometer angle'] is True:
            # Ideally the rows of self,trans_mat should be orthogonal. The angle can be calculated as
            cosa = (trans_mat[0, 0] * trans_mat[1, 0] + trans_mat[0, 1] * trans_mat[1, 1]) / \
                   (np.sqrt(trans_mat[0, 0]**2 + trans_mat[0, 1]**2)
                    * np.sqrt(trans_mat[1, 0]**2 + trans_mat[1, 1]**2))
            angle = np.arccos(cosa)*180 / np.pi  # should be around 90
            print("The angle between the horizontal and vertical micrometer: " +
                  str(angle)+" degrees")


        # Saving the center of the coordinates
        # with open(os.path.join(options['Spatial calib source dir'], self.calibration_id, 'head_fibre_config.dat'), 'r')\
        #         as head_config:
        #     line = head_config.readline()
        #     head_config_map = {}
        #     while line:
        #         line = [name for name in head_config.readline(
        #         ).rstrip().split(' ') if name != '']
        #         if len(line) == 1:
        #             line = [name for name in line[0].split('\t') if name != '']
        #         if len(line) != 0:
        #             head_config_map.update({line[1]: line[0]})
        
        from .cxrs import read_fibre_config
        patch_dict = read_fibre_config(self.calibration_id)

        self.cxrs_chan_cent = {}
        for chan in chan_cent.keys():
            if 'ref' in chan:
                try:
                    curr_chan_data = {chan[3:].upper(): [patch_dict[chan[3:].upper()], [chan_cent[chan][0]]]}
                except KeyError: 
                    #the fiber is broken according to the config
                    curr_chan_data = {chan[3:].upper(): ["N.A.", [chan_cent[chan][0]]]}
                self.cxrs_chan_cent.update(curr_chan_data)
        
        
        if options['Plot'] is True:
            plt.imshow(summed_image)
            for key in self.cxrs_chan_cent:
                if 'ALL' not in image_params[0]:
                    plt.scatter(self.cxrs_chan_cent[key][1][0][-2], self.cxrs_chan_cent[key][1][0][-1],
                                color='tab:red', marker='x')
                    if self.cxrs_chan_cent[key][0][0] == 'H' or self.cxrs_chan_cent[key][0][0] == 'N':
                        plt.text(self.cxrs_chan_cent[key][1][0][-2], self.cxrs_chan_cent[key][1][0][-1],
                                 self.cxrs_chan_cent[key][0], color='white')
                    else:
                        plt.text(self.cxrs_chan_cent[key][1][0][-2]-10, self.cxrs_chan_cent[key][1][0][-1],
                                 self.cxrs_chan_cent[key][0], color='white')
            plt.axis('equal')
            plt.show(block=False)
            plt.pause(0.01)
        
        return self.cmos_cxrs_trans_mat


    def process_cmos_to_machine_calib(self, options={}):
        ''' Processing the cmos to machine calibration data. This function opens an interactive matplotlib figure
        If run within Spyder, one has to turn off the Tools/Preferences/IPython console/Graphics/Activate support
        The goal is to find the machine x,y coordinate of the pixels of the CMOS, assuming that they are located
        on the z=0 plane
        INPUT: options - Spatial calib source dir - a string of the location of the calibration files. Perdefault the
                                                    locaiton of the current file + /spatcal
                         Type: 'Points' or 'Fiducial' - Whether the reconstruction is based on fixed known points or
                                                    fiducial curves
        OUTPUT: the calibration variables are produced by a subfunction
        '''

        options_default = {'Spatial calib source dir': os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                                                    'spatcal'),
                           'Type': 'Points'}
        options = {**options_default, **options}

        # Read the point coordinates in real space
        filename = os.path.join(
            options['Spatial calib source dir'], self.calibration_id, 'Geometry', 'calib_image.dat')
        with open(filename, 'r') as pointdata:
            line = pointdata.readline()
            points_rzt = []
            while line:
                line = pointdata.readline().rstrip()
                if len(line) != 0:
                    points_rzt += [[float(data)
                                    for data in line.split(' ') if data != '']]
        points_rzt = np.asarray(points_rzt)

        point_file = os.path.join(
            options['Spatial calib source dir'], self.calibration_id, 'Geometry', 'calib_image_points.dat')
        if os.path.exists(point_file) == True:
            with open(point_file, "r") as f:
                all_data = f.readlines()
            self.points_cmos = list()
            for point in all_data:
                self.points_cmos += [[float(point.split("\n")[0].split(
                    "\t")[0]), float(point.split("\n")[0].split("\t")[1])]]
                plt.scatter(
                    self.points_cmos[-1][0], self.points_cmos[-1][1], color='#FF0000', marker='x')
                # plt.text(self.points_cmos[-1][0]+7, self.points_cmos[-1][1]+7, len(self.points_cmos), color='red')
            self.points_cmos = np.asarray(self.points_cmos)

            filename = os.path.join(
                options['Spatial calib source dir'], self.calibration_id, 'Geometry', 'calib_image.png')
            self.calib_image = np.asarray(plt.imread(filename))
            self.calib_interface = plt.imshow(self.calib_image)
            plt.pause(0.01)
            plt.show(block=False)

            self.start_calibration(points_rzt, options)
        else:
            # Click on an image to signal the point coordinates in a photo
            self.points_cmos = np.array([])
            plt.ion()
            f = plt.figure()
            gs = gridspec.GridSpec(1, 3, width_ratios=[1, 3, 2])
            # Adding the 'buttons'
            ax = plt.subplot(gs[0])
            buttons = OrderedDict()
            buttons['Get Obs.\ Angle'] = [True, partial(
                self.get_obs_angle, points_rzt, options)]
            buttons['Start\nCalibration'] = [True, partial(
                self.start_calibration, points_rzt, options)]
            buttons['Delete Last\nPoint'] = [
                True, self.delete_last_selected_point]
            buttons['Add Point'] = [False, None]
            self.clickbuttons = ClickButtonList(ax, buttons)
            # adding the calibration image with the event handling
            filename = os.path.join(
                options['Spatial calib source dir'], self.calibration_id, 'Geometry', 'calib_image.png')
            self.calib_image = np.asarray(plt.imread(filename))
            plt.subplot(gs[1])
            self.calib_interface = plt.imshow(self.calib_image)
            self.calib_interface.figure.canvas.mpl_connect(
                'button_press_event', self.add_to_selected_points)
            # adding the reference image
            filename = os.path.join(options['Spatial calib source dir'], self.calibration_id,
                                    'Geometry', 'reference_image.png')
            ref_image = np.asarray(plt.imread(filename))
            plt.subplot(gs[2])
            plt.imshow(ref_image)
            f.tight_layout()
            plt.pause(0.01)
            plt.show(block=True)

            # Do some kind of fitting the output should be a function with CMOS coordinate -> real space
            # This part is done when clicking on Start calibration which calls the start_calibration() routine

    def add_to_selected_points(self, event):
        ''' Add CMOS coordinate of clicked point to list of selected points
        '''
        axes = self.calib_interface.axes
        if (event.inaxes != axes) or (self.clickbuttons.buttons['Add Point'].active is False):
            return
        self.points_cmos = np.array(
            list(self.points_cmos)+[[event.xdata, event.ydata]])
        scatterplot = axes.scatter(
            self.points_cmos[:, 0], self.points_cmos[:, 1], color='#FF0000', marker='x')
        axes.draw_artist(scatterplot)
        canvas = self.calib_interface.figure.canvas
        canvas.blit(axes.bbox)

    def add_vector_of_points(self, cmos_XY, color="#00FF00"):
        ''' Plots vector of points to the calibration image
        '''
        axes = self.calib_interface.axes
        scatterplot = axes.scatter(
            cmos_XY[:, 0], cmos_XY[:, 1], color=color, marker='x')
        axes.draw_artist(scatterplot)
        canvas = self.calib_interface.figure.canvas
        canvas.blit(axes.bbox)

    def delete_last_selected_point(self):
        ''' Deletes the last point from the list of selected points
        '''
        if len(self.points_cmos) == 0:
            return
        self.points_cmos = self.points_cmos[:-1]

        axes = self.calib_interface.axes
        axes.cla()
        canvas = self.calib_interface.figure.canvas
        self.calib_interface = axes.imshow(self.calib_image)
        scatterplot = axes.scatter(
            self.points_cmos[:, 0], self.points_cmos[:, 1], color='#FF0000', marker='x')
        axes.draw_artist(self.calib_interface)
        axes.draw_artist(scatterplot)
        canvas.blit(axes.bbox)

    def start_calibration(self, points_rzt, options={}):
        ''' Function connected with the Start calibration button. Starts either the point based or the fiducial curve
        base calibration
        '''
        # Reading the location parameters of the observation point
        if options['Type'] == 'Points':
            self.cmos_to_real, self.real_to_cmos = self.calib_points(
                points_rzt, options=options)
        else:
            raise NotImplementedError(
                'Spatial calibration with fiducial curves not implemented yet.')

    def get_obs_angle(self, points_rzt, options={}):
        ''' Function connected with the Start calibration button. Starts either the point based or the fiducial curve
        base calibration
        '''
        # Reading the location parameters of the observation point
        if options['Type'] == 'Points':
            angle = self.calib_angle_points(points_rzt, options=options)
        else:
            raise NotImplementedError(
                'Spatial calibration with fiducial curves not implemented yet.')

    def calib_points(self, points_rzt, options={}):
        ''' Obtains the calibration data from cmos to machine using a MachineCalibConfig object
        INPUT:
            points_rzt: the location of the calibration points in machine R, Z and Theta coordinates
            options: Elliptical symmetry: Whether elliptical symmetry of the optical system is assumed
                     Circular symmetry: Whether circular symmetry of the optical system is assumed
        '''
        options_default = {'Elliptical symmetry': False,
                           'Circular symmetry': True}
        options = {**options_default, **options}

        if options['Circular symmetry'] is True and options['Elliptical symmetry'] is True:
            raise ValueError(
                'Can not set both Circular symmetry and Elliptical symmetry to True for the calibration')

        if points_rzt.shape[0] > self.points_cmos.shape[0]:
            raise ValueError('Not enough points selected on image')
        if points_rzt.shape[0] < self.points_cmos.shape[0]:
            too_many_points_clicked = True
            while too_many_points_clicked is True:
                self.delete_last_selected_point()
                too_many_points_clicked = points_rzt.shape[0] < self.points_cmos.shape[0]
        self.calibconf = MachineCalibConfig(
            calibration_id=self.calibration_id, options=options)
        self.calibconf.get_optical_axis_midplane_crosspoint()
        # Calculating the part of the points perpendicular to the optical axis:
        point_XY = np.zeros([points_rzt.shape[0], 2])
        for index in range(points_rzt.shape[0]):
            point_xyz = np.asarray([points_rzt[index, 0]*np.cos(points_rzt[index, 2]*np.pi/180),
                                    points_rzt[index, 0] *
                                    np.sin(points_rzt[index, 2]*np.pi/180),
                                    points_rzt[index, 1]])
            point_XY[index, :] = np.asarray(
                self.calibconf.get_image_XY_coord(point_xyz))
#            point_onplane = self.calibconf.get_proj_to_image_plane(point_xyz)
#
#            # Calculating the XY coordinates - the coordinates in the plane perpendicular to the optical axis
#            perp_to_optax = point_onplane-self.calibconf.midplane_crosspoint
#            point_XY[index, 0] = np.dot(perp_to_optax, self.calibconf.image_x_vector)
#            point_XY[index, 1] = np.dot(perp_to_optax, self.calibconf.image_y_vector)

        real_to_cmos = solve_warp_equation(
            point_XY, self.points_cmos, options=options)

        if options['Elliptical symmetry'] is False and options['Circular symmetry'] is False:
            Kx00, Kx10, Kx01, Kx11, Ky00, Ky10, Ky01, Ky11 = real_to_cmos
            cmos_to_real = solve_warp_equation(
                self.points_cmos, point_XY, options=options)
        else:
            Kx00, Kx10, Kx01, Kx11, Ky00, Ky10, Ky01, Ky11 = real_to_cmos
            # cmos_to_real = [(-Kx00+Ky00*Kx01/Ky01)/(Kx10-Ky10*Kx01/Ky01), 1/(Kx10-Ky10*Kx01/Ky01), -Kx01/Ky01/(Kx10-Ky10*Kx01/Ky01), 0,
            #                 (-Kx00+Ky00*Kx10/Ky10)/(Kx01-Ky01*Kx10/Ky10), 1/(Kx01-Ky01*Kx10/Ky10), -Kx10/Ky10/(Kx01-Ky01*Kx10/Ky10), 0]
            multi = 1/(Kx10*Ky01-Kx01*Ky10)
            inverse =np.array([[ multi*Ky01, -multi*Ky10],[-multi*Kx01, multi*Kx10]])
            new_start = np.dot(inverse, np.array([-Kx00, -Ky00]))
            cmos_to_real = [new_start[0], multi*Ky01, -multi*Ky10, 0,
                            new_start[1], -multi*Kx01, multi*Kx10, 0]
            # cmos_to_real = solve_warp_equation(
            #     self.points_cmos, point_XY,  options=options)
        
            
        # Checking the accuracy and plotting the data
        cmos_check = get_points_projection(point_XY, real_to_cmos)
        # print(point_XY-get_points_projection(cmos_check, cmos_to_real))
        self.add_vector_of_points(cmos_check)

        return cmos_to_real, real_to_cmos

    def calib_angle_points(self, points_rzt, options={}):
        if points_rzt.shape[0] > self.points_cmos.shape[0]:
            raise ValueError('Not enough points selected on image')
        if points_rzt.shape[0] < self.points_cmos.shape[0]:
            too_many_points_clicked = True
            while too_many_points_clicked is True:
                self.delete_last_selected_point()
                too_many_points_clicked = points_rzt.shape[0] < self.points_cmos.shape[0]

        self.calibconf = MachineCalibConfig(
            calibration_id=self.calibration_id, options=options)
        points_xyz = np.zeros(points_rzt.shape)
        index = 0
        for index in range(points_rzt.shape[0]):
            points_xyz[index, :] = np.asarray([points_rzt[index, 0]*np.cos(points_rzt[index, 2]*np.pi/180),
                                               points_rzt[index, 0] *
                                               np.sin(
                                                   points_rzt[index, 2]*np.pi/180),
                                               points_rzt[index, 1]])
            index += 1
        angle = optimize_angle(points_xyz, self.points_cmos, self.calibconf)
        return angle

    def calc_apdcam_cmos_transform(self, flip_horizontally):

        if int(self.calibration_id) == 2021:
            # reading the corresponding optical channels
            channels = ["20", "39", "38", "1", "2", "3"]

            try:
                currdir = os.path.dirname(os.path.abspath(__file__))
            except NameError:
                currdir = os.path.abspath(os.getcwd())

            opt_chan_2018 = {}
            dir2018 = os.path.join(currdir, 'spatcal', '2018')
            # these correspond to the channels in the "channels" variable
            fileID = [29, 56, 55, 4, 5, 6]
            padded_fileID = ["{:08d}".format(number) for number in fileID]
            all_files = os.listdir(dir2018)
            all_files_dict = {}
            for file in all_files:
                all_files_dict[file.split("_")[0]] = file
            rel_files2018 = [all_files_dict[file] for file in padded_fileID]

            opt_chan_2021 = {}
            dir2021 = os.path.join(currdir, 'spatcal', '2021')
            fileID = ["16", "18", "19", "20", "21", "22"]
            all_files = np.asarray(os.listdir(dir2021))
            all_files_dict = {}
            for file in all_files:
                all_files_dict[file.split("_")[0]] = file
            rel_files2021 = [all_files_dict[file] for file in fileID]

            for fileindex in range(len(channels)):
                image = np.asarray(plt.imread(os.path.join(
                    dir2018, rel_files2018[fileindex]))).astype("float")
                if flip_horizontally == True:
                    image = np.fliplr(image)
                image = image/np.var(image)
                image = image-np.median(image)
                image[image < 100] = 0
                image = median_filter(image, size=3)
                x_weight = np.sum(image, axis=0)
                y_weight = np.sum(image, axis=1)
                x_mean = np.average(np.arange(len(x_weight)), weights=x_weight)
                y_mean = np.average(np.arange(len(y_weight)), weights=y_weight)

                opt_chan_2018[channels[fileindex]] = np.array([x_mean, y_mean])

                image = np.asarray(plt.imread(
                    os.path.join(dir2021, rel_files2021[fileindex])))
                if flip_horizontally == True:
                    image = np.fliplr(image)
                image[np.where(image < np.max(image)*0.5)] = 0
                x_weight = np.sum(image, axis=0)
                y_weight = np.sum(image, axis=1)
                x_mean = np.average(np.arange(len(x_weight)), weights=x_weight)
                y_mean = np.average(np.arange(len(y_weight)), weights=y_weight)
                opt_chan_2021[channels[fileindex]] = np.array([x_mean, y_mean])

            # calculating the transfer matrix between the optical channel locations of 2018 and 2021
            # practically optchan2021 = a + B*optchan2018, for every channel where A is a vector of length 2 and B is 2 by 2 rotation matrix
            # this could be transformed to a linear equation with reasonable accuracy, as the rotation is small, but it is probably better to get a more general solution
            a0 = np.mean([opt_chan_2021[channel]-opt_chan_2018[channel]
                         for channel in channels], axis=0)
            b0 = 0
            starter = np.array([a0[0], a0[1], b0])
            error_func = partial(transform_error, opt_chan_2018, opt_chan_2021)
            trans = minimize(error_func, starter, method='Powell')
            a = [trans['x'][0], trans['x'][1]]
            b = trans['x'][2]
            b = b.clip(min=-np.pi/2)
            b = b.clip(max=np.pi/2)
            c, s = np.cos(b), np.sin(b)
            B = np.array(((c, -s), (s, c)))

            return a, B
        else:
            raise NotImplementedError(
                "Currently only works for 2021 calibration")

    def calc_cxrs_cmos_transform(self, summed_image, refimage):
        if int(self.calibration_id) == 2021:
               
            with open(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'spatcal',
                       self.calibration_id, 'Geometry', 'cxrs_calib_image_points.dat'), 'r') as calib_file:
                lines = calib_file.readlines()
            source_XY = np.zeros([len(lines)-1, 2])
            proj_XY = np.zeros([len(lines)-1, 2])
            line_index = 0
            for line in lines[1:]:
                source_XY[line_index,0] = float(line.split('\t')[1])
                source_XY[line_index,1] = float(line.split('\t')[2])
                proj_XY[line_index,0] = float(line.split('\t')[3])
                proj_XY[line_index,1] = float(line.split('\t')[4].split("\n")[0])
                line_index += 1
            
            
            cxrs_to_cmos = solve_warp_equation(source_XY, proj_XY, options={'Elliptical symmetry': False,
                                                                            'Circular symmetry': True})
            
            # Checking the accuracy and plotting the data
            # cmos_check = get_points_projection(source_XY, cxrs_to_cmos)

            # plt.imshow(summed_image)
            # for points in proj_XY:
            #     plt.scatter(points[0], points[1], color="red")
            # for points in cmos_check:
            #     plt.scatter(points[0], points[1], color="blue", marker="x")
            return cxrs_to_cmos
        else:
            raise NotImplementedError(
                "Currently only works for 2021 calibration")


class MachineCalibConfig:
    '''Object used to processing the calibration from the CMOS to the machine coordinates
    '''

    def __init__(self, calibration_id=None, options={}):
        ''' init function, reads the calibration data from cmos to machine if calibration_id is known
        INPUT: calibration_id - the name of the directory with the calibration data
               options - a keyword that is passed down to the read() function
        OUTUPUT: NOne
        '''
        options_default = {}
        options = {**options_default, **options}

        if calibration_id is not None:
            self.read(calibration_id, options)

    def read(self, calibration_id, options):
        '''Reads the cmos to machine calibration information
        INPUT: alibration_id - the name of the directory with the calibration data
               options - not needed
        OUTPUT: The following variables are created
            self.obs_pont - the location of the observation point
            self.opt_axis_norm - the vector of the optical axis
            self.image_x_vector, self.image_y_vector - the vectors approximately along the CMOS x and y directions,
                        projected on a plane (image plane) that is perpendicular to the optical axis and which crosses
                        the optical axis at its intersection with the z=0 plane
        '''

        self.calibration_id = calibration_id
        # Reading the location parameters of the observation point
        filename = os.path.join(
            options['Spatial calib source dir'], self.calibration_id, 'Geometry', 'observation.dat')
        with open(filename, 'r') as obsdata:
            # skipping the comments
            for i in range(4):
                obsdata.readline()
            # Getting the observation point
            self.obs_point = np.asarray([float(coordval) for coordval in obsdata.readline().rstrip().split(' ')
                                         if coordval != ''])
            # Getting the vector of the optical axis
            point_on_opt_axis = np.asarray([float(coordval) for coordval in obsdata.readline().rstrip().split(' ')
                                            if coordval != ''])

            self.opt_axis_norm = point_on_opt_axis - self.obs_point
            self.opt_axis_norm = self.opt_axis_norm / \
                np.linalg.norm(self.opt_axis_norm)

            # Getting vector along image x
            self.image_x_vector = np.asarray([float(coordval) for coordval in obsdata.readline().rstrip().split(' ')
                                              if coordval != ''])

            self.image_x_vector = self.image_x_vector - self.opt_axis_norm * np.dot(self.image_x_vector,
                                                                                    self.opt_axis_norm)
            self.image_x_vector = self.image_x_vector / \
                np.linalg.norm(self.image_x_vector)
            self.image_y_vector = - \
                np.cross(self.image_x_vector, self.opt_axis_norm)

    def get_optical_axis_midplane_crosspoint(self, obs_point=None, opt_axis_norm=None):
        ''' Calculating where the optical axis crosses the z=0 plane
        INPUT:
            obs_point: the observation point of the optics, if undefined, then self.obs_point is used
            obt_axis_norm: the unit vector of the optical axis, if undefined, then self.opt_axis_norm is used
        OUTPUT:
            self.midplane_crosspoint is created which is the intersection of the optical axis with the z=0 plane
        '''
        if obs_point is not None:
            self.obs_point = obs_point
        if opt_axis_norm is not None:
            self.opt_axis_norm = opt_axis_norm

        length_along_optax = -self.obs_point[2]/self.opt_axis_norm[2]
        self.midplane_crosspoint = self.obs_point + \
            self.opt_axis_norm * length_along_optax
        # The equation of the plane at the self.midplane_crosspoint crossing this point is
        # 0 = (x-self.midplane_crosspoint[0])*self.opt_axis_norm[0] +\
        #     (y-self.midplane_crosspoint[1])*self.opt_axis_norm[1] +\
        #     (z-self.midplane_crosspoint[2])*self.opt_axis_norm[2]

    def get_proj_to_image_plane(self, point_xyz, obs_point=None, opt_axis_norm=None):
        ''' Calculates the projection of points on the image plane
        Image plane  is perpendicular to the optical axis and and crosses the optical axis at the intersection of the
        optical axis with the z=0 plane
        The projection: point_xyz is connected with the observation point and the intersection of this
        line with the image plane is calculated
        INPUT:
            point_xyz - the point to project
            obs_point: the observation point of the optics, if undefined, then self.obs_point is used
            obt_axis_norm: the unit vector of the optical axis, if undefined, then self.opt_axis_norm is used
        OUTPUT:
            point_onplane . the x,y,z coordinate of the projected point
        '''
        if obs_point is not None:
            self.obs_point = obs_point
        if opt_axis_norm is not None:
            self.opt_axis_norm = opt_axis_norm

        if hasattr(self, 'midplane_crosspoint') is False:
            self.get_optical_axis_midplane_crosspoint()
        # The line connecting point_xyz and self.obs_point crosses the plane defined previously at
        x_onplane = (self.midplane_crosspoint[0]*self.opt_axis_norm[0] +
                     (point_xyz[0]/(self.obs_point[0]-point_xyz[0])*(self.obs_point[1]-point_xyz[1])+self.midplane_crosspoint[1]-point_xyz[1])*self.opt_axis_norm[1] +
                     (point_xyz[0]/(self.obs_point[0]-point_xyz[0])*(self.obs_point[2]-point_xyz[2])+self.midplane_crosspoint[2]-point_xyz[2])*self.opt_axis_norm[2]) /\
            (self.opt_axis_norm[0]+self.opt_axis_norm[1]*(self.obs_point[1]-point_xyz[1])/(self.obs_point[0] -
             point_xyz[0])+self.opt_axis_norm[2]*(self.obs_point[2]-point_xyz[2])/(self.obs_point[0]-point_xyz[0]))
        y_onplane = (self.obs_point[1]-point_xyz[1])/(self.obs_point[0] -
                                                      point_xyz[0])*(x_onplane-point_xyz[0])+point_xyz[1]
        z_onplane = (self.obs_point[2]-point_xyz[2])/(self.obs_point[0] -
                                                      point_xyz[0])*(x_onplane-point_xyz[0])+point_xyz[2]
        point_onplane = np.array([x_onplane, y_onplane, z_onplane])

#        dist_from_implane = np.dot(self.midplane_crosspoint-point_xyz, self.opt_axis_norm)
#        point_onplane = point_xyz+dist_from_implane*self.opt_axis_norm
        # Checking, all of the following should be 0
#        obs_to_point = point_onplane-self.obs_point
#        x_onplane, y_onplane, z_onplane = point_onplane
#        print((x_onplane-self.midplane_crosspoint[0])*self.opt_axis_norm[0]+
#        (y_onplane-self.midplane_crosspoint[1])*self.opt_axis_norm[1]+
#        (z_onplane-self.midplane_crosspoint[2])*self.opt_axis_norm[2])
#        print((x_onplane-point_xyz[0])/(self.obs_point[0]-point_xyz[0])-(y_onplane-point_xyz[1])/(self.obs_point[1]-point_xyz[1]))
#        print((x_onplane-point_xyz[0])/(self.obs_point[0]-point_xyz[0])-(z_onplane-point_xyz[2])/(self.obs_point[2]-point_xyz[2]))
#        print(np.dot(point_onplane-self.midplane_crosspoint, self.opt_axis_norm))
        return point_onplane

    def get_image_XY_coord(self, points_xyz, obs_point=None, opt_axis_norm=None,
                           image_x_vector=None, image_y_vector=None):
        ''' Obtains the coordinate of a bunch of points projected on the image plane in the image_x_vector,
        image_y_vector coordinate system
        INPUT:
            points_xyz - a list of points in their machine xyz coordinates (not yet projected on the image plane)
            obs_point: the observation point of the optics, if undefined, then self.obs_point is used
            opt_axis_norm: the unit vector of the optical axis, if undefined, then self.opt_axis_norm is used
            image_x_vector: the x axis in the image plane, if undefined, then self.image_x_vector is used
            image_y_vector: the y axis in the image plane, if undefined, then self.image_y_vector is used
        OUTPUT:
            point_XY - a list of the coordinates
        '''
        if obs_point is not None:
            self.obs_point = obs_point
        if opt_axis_norm is not None:
            self.opt_axis_norm = opt_axis_norm
        if image_x_vector is not None:
            self.image_x_vector = image_x_vector
        if image_y_vector is not None:
            self.image_y_vector = image_y_vector

        if hasattr(self, 'midplane_crosspoint') is False:
            self.get_optical_axis_midplane_crosspoint()

        if type(points_xyz) is not list:
            points_xyz = [points_xyz]

        points_XY = []
        for point in points_xyz:
            proj = self.get_proj_to_image_plane(point)
            # Calculating the XY coordinates
            perp_to_optax = proj-self.midplane_crosspoint
            point_XY = np.asarray([np.dot(perp_to_optax, self.image_x_vector),
                                   np.dot(perp_to_optax, self.image_y_vector)])
            points_XY = points_XY + [point_XY]

        return points_XY


def solve_warp_equation(source_XY, proj_XY, options={}):
    ''' Calculates the projection parameters between two planes
    IT finds the best set of coordinates with the least squares method
    INPUT:
        source_XY - the XY coordinates of the sources
        proj_XY - the coordinates of the projected points, in the same order as source_XY
        options: Elliptical symmetry - if the projection is assumed to be elliptically symmetrical
                 Circular symmetry - if the projection is assumed to have a circular symmetry. E.g. if the points of
                 source_XY are on one plane perpendicular to the optical axis and proj_XY are as well
    OUTPUT:
        A set of parameters defining the projection
    '''
    options_default = {'Elliptical symmetry': False,
                       'Circular symmetry': True}
    options = {**options_default, **options}

    source_XY = np.asarray(source_XY)
    proj_XY = np.asarray(proj_XY)

    if options['Elliptical symmetry'] is True:
        K_mat = np.zeros([np.shape(source_XY)[0], 3])
        K_mat[:, 0] = 1
        K_mat[:, 1] = source_XY[:, 0]
        K_mat[:, 2] = source_XY[:, 1]
        Kx_vec = proj_XY[:, 0]
        Ky_vec = proj_XY[:, 1]

        Kx00, Kx10, Kx01 = np.linalg.solve(
            np.dot(np.transpose(K_mat), K_mat), np.dot(np.transpose(K_mat), Kx_vec))
        Ky00, Ky10, Ky01 = np.linalg.solve(
            np.dot(np.transpose(K_mat), K_mat), np.dot(np.transpose(K_mat), Ky_vec))
        res = np.array([Kx00, Kx10, Kx01, 0, Ky00, Ky10, Ky01, 0])
    elif options['Circular symmetry'] is True:
        K_mat = np.zeros([np.shape(source_XY)[0]*2, 4])
        K_mat[:, 0] = np.concatenate([source_XY[:, 0], -source_XY[:, 1]])
        K_mat[:, 1] = np.concatenate([source_XY[:, 1], source_XY[:, 0]])
#        K_mat[:, 0] = np.concatenate([source_XY[:, 0], source_XY[:, 1]])
#        K_mat[:, 1] = np.concatenate([source_XY[:, 1], -source_XY[:, 0]])
        K_mat[:np.shape(source_XY)[0], 2] = 1
        K_mat[np.shape(source_XY)[0]:, 3] = 1
        K_vec = np.concatenate([proj_XY[:, 0], proj_XY[:, 1]])

        Kx10, Kx01, Kx00, Ky00 = np.linalg.solve(
            np.dot(np.transpose(K_mat), K_mat), np.dot(np.transpose(K_mat), K_vec))
        res = np.array([Kx00, Kx10, Kx01, 0, Ky00, Kx01, -Kx10, 0])
#        res = np.array([Kx00, Kx10, Kx01, 0, Ky00, -Kx01, Kx10, 0])

    else:
        K_mat = np.zeros([np.shape(source_XY)[0], 4])
        K_mat[:, 0] = 1
        K_mat[:, 1] = source_XY[:, 0]
        K_mat[:, 2] = source_XY[:, 1]
        K_mat[:, 3] = source_XY[:, 0]*source_XY[:, 1]
        Kx_vec = proj_XY[:, 0]
        Ky_vec = proj_XY[:, 1]

        Kx00, Kx10, Kx01, Kx11 = np.linalg.solve(np.dot(np.transpose(K_mat), K_mat),
                                                 np.dot(np.transpose(K_mat), Kx_vec))
        Ky00, Ky10, Ky01, Ky11 = np.linalg.solve(np.dot(np.transpose(K_mat), K_mat),
                                                 np.dot(np.transpose(K_mat), Ky_vec))
        res = np.array([Kx00, Kx10, Kx01, Kx11, Ky00, Ky10, Ky01, Ky11])
    return res


def get_points_projection(source_XY, proj_vect):
    ''' Calculates the projection of a point based on the output of solve_warp_equation
    INPUT:
        source_XY - the coordinate of the point in the source plane
        proj_vect - the result of the solve_warp_equation
    OUTPUT:
        proj_XY - the coordinates of the point in the projection plane
    '''
    Kx00, Kx10, Kx01, Kx11, Ky00, Ky10, Ky01, Ky11 = proj_vect
    proj_XY = np.asarray([Kx00+source_XY[:, 0]*Kx10+source_XY[:, 1]*Kx01+source_XY[:, 0]*source_XY[:, 1]*Kx11,
                          Ky00+source_XY[:, 0]*Ky10+source_XY[:, 1]*Ky01+source_XY[:, 0]*source_XY[:, 1]*Ky11])
    proj_XY = np.transpose(proj_XY)
    return proj_XY


def optimize_angle(point_xyz, points_cmos, calibconf):
    calibconf.get_optical_axis_midplane_crosspoint()
    starting_vect = calibconf.midplane_crosspoint - calibconf.obs_point
    starting_dist = np.linalg.norm(starting_vect)
    start_phi = np.arctan(starting_vect[1]/starting_vect[0])
    start_theta = np.arccos(starting_vect[2]/starting_dist)
    part_proj_error = partial(
        projection_error, calibconf, point_xyz, points_cmos)
    from scipy.optimize import minimize
    res = minimize(part_proj_error, [start_phi, start_theta, starting_dist])
    [phi, theta, dist] = res.x
    location = np.array([dist*np.sin(theta)*np.cos(phi),
                         dist*np.sin(theta)*np.sin(phi),
                         dist * np.cos(theta)])


def projection_error(calibconf, points_xyz_input, points_cmos_input, opti):
    [phi, theta, dist] = opti
    import copy
    conf = copy.deepcopy(calibconf)
    points_cmos = copy.deepcopy(points_cmos_input)
    points_xyz = copy.deepcopy(points_xyz_input)
    vector_to_obs_point = np.array([dist*np.sin(theta)*np.cos(phi),
                                    dist*np.sin(theta)*np.sin(phi),
                                    dist * np.cos(theta)])
    orig_crosspoint = conf.midplane_crosspoint
    orig_norm = conf.opt_axis_norm
    orig_obs_point = conf.obs_point
    conf.opt_axis_norm = copy.deepcopy(vector_to_obs_point)
    conf.opt_axis_norm = conf.opt_axis_norm/np.linalg.norm(conf.opt_axis_norm)
    conf.get_optical_axis_midplane_crosspoint()
    conf.obs_point = conf.midplane_crosspoint - vector_to_obs_point
#    if np.linalg.norm(orig_crosspoint-conf.midplane_crosspoint) > 1.:
#        conf.opt_axis_norm = orig_norm
#        conf.get_optical_axis_midplane_crosspoint()
#        conf.obs_point = orig_obs_point

    # Getting vector along image x
    conf.image_x_vector = conf.image_x_vector - conf.opt_axis_norm * np.dot(conf.image_x_vector,
                                                                            conf.opt_axis_norm)
    conf.image_x_vector = conf.image_x_vector / \
        np.linalg.norm(conf.image_x_vector)
    conf.image_y_vector = -np.cross(conf.image_x_vector, conf.opt_axis_norm)

    point_XY = np.zeros([points_xyz.shape[0], 2])
    for index in range(points_xyz.shape[0]):
        point_XY[index, :] = np.asarray(
            conf.get_image_XY_coord(points_xyz[index, :]))

    # Fitting to the port circle
    real_space_circle_points = point_XY[11:, :]
    [r_real, center_real] = fit_circle(real_space_circle_points)
    cmos_circle_points = points_cmos[11:, :]
    [r_cmos, center_cmos] = fit_circle(cmos_circle_points)
    point_XY[11:15, :] = center_real
    points_cmos[11:15, :] = center_cmos
    point_XY = point_XY[:15, :]
    points_cmos = points_cmos[:15, :]

    # getting the distance from the first and second selcted point
    dist = []
    for point in range(points_cmos.shape[0]):
        dist += [np.linalg.norm(point_XY-point_XY[point, :], axis=1)]

    # getting the distance between the CMOS points
    dist_CMOS = []
    for point in range(points_cmos.shape[0]):
        dist_CMOS += [np.linalg.norm(points_cmos -
                                     points_cmos[point, :], axis=1)]

    ratio = dist_CMOS[0][2]/dist[0][2]
    error = 0
    for point in range(points_cmos.shape[0]):
        error += np.sum(np.abs(dist[point]*ratio-dist_CMOS[point]))

    return error*np.linalg.norm(orig_crosspoint-conf.midplane_crosspoint)


def fit_circle(points):
    x = points[:, 0]
    y = points[:, 1]

    # coordinates of the barycenter
    x_m = np.mean(x)
    y_m = np.mean(y)

    # calculation of the reduced coordinates
    u = x - x_m
    v = y - y_m

    # linear system defining the center (uc, vc) in reduced coordinates:
    #    Suu * uc +  Suv * vc = (Suuu + Suvv)/2
    #    Suv * uc +  Svv * vc = (Suuv + Svvv)/2
    Suv = np.sum(u*v)
    Suu = np.sum(u**2)
    Svv = np.sum(v**2)
    Suuv = np.sum(u**2 * v)
    Suvv = np.sum(u * v**2)
    Suuu = np.sum(u**3)
    Svvv = np.sum(v**3)

    # Solving the linear system
    A = np.array([[Suu, Suv], [Suv, Svv]])
    B = np.array([Suuu + Suvv, Svvv + Suuv])/2.0
    uc, vc = np.linalg.solve(A, B)

    xc_1 = x_m + uc
    yc_1 = y_m + vc

    # Calcul des distances au centre (xc_1, yc_1)
    Ri_1 = np.sqrt((x-xc_1)**2 + (y-yc_1)**2)
    R_1 = np.mean(Ri_1)
    residu_1 = np.sum((Ri_1-R_1)**2)

    center = np.array([xc_1, yc_1])
    return R_1, center
# ----------------------------------------Graphics----------------------------------------------------------------------
# The following two classes are needed for selecting points if the cmos to machine calibration is called


class ClickButtonList:
    def __init__(self, axes, button_dict):
        num_of_buttons = len(button_dict.keys())
        buttons = axes.barh(np.arange(num_of_buttons),
                            np.ones(num_of_buttons), height=0.5)
        self.buttons = []
        index = 0
        self.buttons = OrderedDict()
        for key in button_dict:
            self.buttons[key] = Button(buttons[index], key,
                                       single_event=button_dict[key][0],
                                       connected_function=button_dict[key][1])
            index += 1
        self.active_button_id = None


class Button:
    def __init__(self, button, button_name, single_event=True, connected_function=None):
        self.button = button
        self.button_name = button_name
        self.connected_function = connected_function
        self.active = False
        self.single_event = single_event
        self.connect()
        plt.pause(0.1)
        self.draw_button(state='off')

    def connect(self):
        self.cidpress = self.button.figure.canvas.mpl_connect(
            'button_press_event', self.on_press)
        if self.single_event is True:
            self.cidpress = self.button.figure.canvas.mpl_connect(
                'button_release_event', self.on_release)

    def on_press(self, event):
        if event.inaxes != self.button.axes:
            return
        contains, attrd = self.button.contains(event)
        if contains is False:
            self.active = False
            self.draw_button(state='off')
        else:
            if self.active is False:
                self.active = True
                self.draw_button(state='on')
            else:
                self.active = False
                self.draw_button(state='off')

    def on_release(self, event):
        if self.active is False:
            return
        self.connected_function()
        self.active = False
        self.draw_button(state='off')

    def draw_button(self, state='off'):
        if state == 'off':
            color = '#1f77b4'
        else:
            color = '#800000'
        self.button.set_color(color)
        canvas = self.button.figure.canvas
        axes = self.button.axes
        bbox = axes.get_window_extent().transformed(
            self.button.figure.dpi_scale_trans.inverted())
        width = int(bbox.width * self.button.figure.dpi/10)
        text = self.button.axes.text(self.button.get_x()+self.button.get_width()/2,
                                     self.button.get_y()+self.button.get_height()/2,
                                     self.button_name, ha='center', va='center', fontsize=width, color='white')
        axes.draw_artist(self.button)
        axes.draw_artist(text)
        axes.axis('off')
        canvas.blit(axes.bbox)


def transform_error(opt_chan_2018, opt_chan_2021, trans):
    a = [trans[0], trans[1]]
    b = trans[2].clip(min=-np.pi/2, max=np.pi/2)
    c, s = np.cos(b), np.sin(b)
    B = np.array(((c, -s), (s, c)))
    error = 0
    for channel in opt_chan_2018.keys():
        vect2021 = opt_chan_2021[channel]
        vect2018 = opt_chan_2018[channel]
        error += np.sum(np.abs(vect2021-(a+np.dot(B, vect2018))))
    return error
